//Generated by gql-server
//DO NOT EDIT
package gen

import (
	"github.com/beinan/gql-server/logging"
	. "github.com/beinan/gql-server/resolver"
	"github.com/vektah/gqlparser/ast"
)

type GqlUserResolver struct {
	resolver UserResolver
}

func MkGqlUserResolver(resolver UserResolver) GqlUserResolver {
	return GqlUserResolver{
		resolver: resolver,
	}
}

func MkGqlUserResolvers(resolvers []UserResolver) []GqlResolver {
	gqlResolvers := make([]GqlResolver, len(resolvers))
	for i, resolver := range resolvers {
		gqlResolvers[i] = MkGqlUserResolver(resolver)
	}
	return gqlResolvers
}

func (r GqlUserResolver) Resolve(ctx Context, sel ast.SelectionSet) GqlResults {
	return GqlResolveSelections(ctx, sel, r.resolveField)
}

func (r GqlUserResolver) resolveField(ctx Context, field *ast.Field) GqlResultValue {
	switch field.Name {

	case "id":

		//for immediate value
		return r.resolver.Id()

	case "name":

		//for immediate value
		return r.resolver.Name()

	case "email":

		//for immediate value
		return r.resolver.Email()

	case "friends":

		//for field with parameters
		span, ctx := logging.StartSpanFromContext(ctx, "User -- friends")
		defer span.Finish()

		startValue, _ := field.Arguments.ForName("start").Value.Value(nil)

		pageSizeValue, _ := field.Arguments.ForName("pageSize").Value.Value(nil)

		resolver := r.resolver.Friends(ctx, startValue.(int64), pageSizeValue.(int64))

		//if it's array, resolver each element
		gqlResolvers := MkGqlUserResolvers(resolver)
		return GqlResolveValues(ctx, gqlResolvers, field.SelectionSet)

	default:
		panic("Unsupported field")
	}
}

type GqlQueryResolver struct {
	resolver QueryResolver
}

func MkGqlQueryResolver(resolver QueryResolver) GqlQueryResolver {
	return GqlQueryResolver{
		resolver: resolver,
	}
}

func MkGqlQueryResolvers(resolvers []QueryResolver) []GqlResolver {
	gqlResolvers := make([]GqlResolver, len(resolvers))
	for i, resolver := range resolvers {
		gqlResolvers[i] = MkGqlQueryResolver(resolver)
	}
	return gqlResolvers
}

func (r GqlQueryResolver) Resolve(ctx Context, sel ast.SelectionSet) GqlResults {
	return GqlResolveSelections(ctx, sel, r.resolveField)
}

func (r GqlQueryResolver) resolveField(ctx Context, field *ast.Field) GqlResultValue {
	switch field.Name {

	case "getUser":

		//for field with parameters
		span, ctx := logging.StartSpanFromContext(ctx, "Query -- getUser")
		defer span.Finish()

		idValue, _ := field.Arguments.ForName("id").Value.Value(nil)

		resolver := r.resolver.GetUser(ctx, idValue.(ID))

		//not array, using NamedType of the return type
		gqlResolver := MkGqlUserResolver(resolver)
		return gqlResolver.Resolve(ctx, field.SelectionSet)

	case "getUsers":

		//for field with parameters
		span, ctx := logging.StartSpanFromContext(ctx, "Query -- getUsers")
		defer span.Finish()

		startValue, _ := field.Arguments.ForName("start").Value.Value(nil)

		pageSizeValue, _ := field.Arguments.ForName("pageSize").Value.Value(nil)

		resolver := r.resolver.GetUsers(ctx, startValue.(int64), pageSizeValue.(int64))

		//if it's array, resolver each element
		gqlResolvers := MkGqlUserResolvers(resolver)
		return GqlResolveValues(ctx, gqlResolvers, field.SelectionSet)

	default:
		panic("Unsupported field")
	}
}

type GqlMutationResolver struct {
	resolver MutationResolver
}

func MkGqlMutationResolver(resolver MutationResolver) GqlMutationResolver {
	return GqlMutationResolver{
		resolver: resolver,
	}
}

func MkGqlMutationResolvers(resolvers []MutationResolver) []GqlResolver {
	gqlResolvers := make([]GqlResolver, len(resolvers))
	for i, resolver := range resolvers {
		gqlResolvers[i] = MkGqlMutationResolver(resolver)
	}
	return gqlResolvers
}

func (r GqlMutationResolver) Resolve(ctx Context, sel ast.SelectionSet) GqlResults {
	return GqlResolveSelections(ctx, sel, r.resolveField)
}

func (r GqlMutationResolver) resolveField(ctx Context, field *ast.Field) GqlResultValue {
	switch field.Name {

	case "updateUserName":

		//for field with parameters
		span, ctx := logging.StartSpanFromContext(ctx, "Mutation -- updateUserName")
		defer span.Finish()

		idValue, _ := field.Arguments.ForName("id").Value.Value(nil)

		nameValue, _ := field.Arguments.ForName("name").Value.Value(nil)

		resolver := r.resolver.UpdateUserName(ctx, idValue.(ID), nameValue.(string))

		//not array, using NamedType of the return type
		gqlResolver := MkGqlUserResolver(resolver)
		return gqlResolver.Resolve(ctx, field.SelectionSet)

	case "updateUser":

		//for field with parameters
		span, ctx := logging.StartSpanFromContext(ctx, "Mutation -- updateUser")
		defer span.Finish()

		idValue, _ := field.Arguments.ForName("id").Value.Value(nil)

		userInputMap, _ := field.Arguments.ForName("userInput").Value.Value(nil)
		userInputValue := MakeUserInput(userInputMap.(map[string]interface{}))
		resolver := r.resolver.UpdateUser(ctx, idValue.(ID), userInputValue)

		//not array, using NamedType of the return type
		gqlResolver := MkGqlUserResolver(resolver)
		return gqlResolver.Resolve(ctx, field.SelectionSet)

	default:
		panic("Unsupported field")
	}
}
