//Generated by gql-server
//DO NOT EDIT
package gen

import (
	"github.com/beinan/gql-server/logging"
	. "github.com/beinan/gql-server/resolver"
	"github.com/vektah/gqlparser/ast"
)

type GqlUserResolver struct {
	resolver UserResolver
}

func MkGqlUserResolver(resolver UserResolver) GqlUserResolver {
	return GqlUserResolver{
		resolver: resolver,
	}
}

func MkGqlUserResolvers(resolvers []UserResolver) []GqlResolver {
	gqlResolvers := make([]GqlResolver, len(resolvers))
	for i, resolver := range resolvers {
		gqlResolvers[i] = MkGqlUserResolver(resolver)
	}
	return gqlResolvers
}

func (r GqlUserResolver) Resolve(ctx Context, sel ast.SelectionSet) GqlResults {
	return GqlResolveSelections(ctx, sel, r.resolveField)
}

func (r GqlUserResolver) resolveField(ctx Context, field *ast.Field) GqlResultValue {
	switch field.Name {

	case "id":

		//for immediate value
		return r.resolver.Id()

	case "name":

		//for immediate value
		return r.resolver.Name()

	case "email":

		//for immediate value
		return r.resolver.Email()

	case "friends":

		//for field with parameters
		span, ctx := logging.StartSpanFromContext(ctx, "User -- friends")
		defer span.Finish()

		startRawValue, _ := field.Arguments.ForName("start").Value.Value(nil)

		startValue := startRawValue.(int64)

		pageSizeRawValue, _ := field.Arguments.ForName("pageSize").Value.Value(nil)

		pageSizeValue := pageSizeRawValue.(int64)

		resolver := r.resolver.Friends(ctx, startValue, pageSizeValue)

		//if it's array, resolver each element
		gqlResolvers := MkGqlUserResolvers(resolver)
		return GqlResolveValues(ctx, gqlResolvers, field.SelectionSet)

	default:
		panic("Unsupported field")
	}
}

type GqlQueryResolver struct {
	resolver QueryResolver
}

func MkGqlQueryResolver(resolver QueryResolver) GqlQueryResolver {
	return GqlQueryResolver{
		resolver: resolver,
	}
}

func MkGqlQueryResolvers(resolvers []QueryResolver) []GqlResolver {
	gqlResolvers := make([]GqlResolver, len(resolvers))
	for i, resolver := range resolvers {
		gqlResolvers[i] = MkGqlQueryResolver(resolver)
	}
	return gqlResolvers
}

func (r GqlQueryResolver) Resolve(ctx Context, sel ast.SelectionSet) GqlResults {
	return GqlResolveSelections(ctx, sel, r.resolveField)
}

func (r GqlQueryResolver) resolveField(ctx Context, field *ast.Field) GqlResultValue {
	switch field.Name {

	case "getUser":

		//for field with parameters
		span, ctx := logging.StartSpanFromContext(ctx, "Query -- getUser")
		defer span.Finish()

		idRawValue, _ := field.Arguments.ForName("id").Value.Value(nil)

		idValue := idRawValue.(ID)

		resolver := r.resolver.GetUser(ctx, idValue)

		//not array, using NamedType of the return type
		gqlResolver := MkGqlUserResolver(resolver)
		return gqlResolver.Resolve(ctx, field.SelectionSet)

	case "getUsers":

		//for field with parameters
		span, ctx := logging.StartSpanFromContext(ctx, "Query -- getUsers")
		defer span.Finish()

		startRawValue, _ := field.Arguments.ForName("start").Value.Value(nil)

		startValue := startRawValue.(int64)

		pageSizeRawValue, _ := field.Arguments.ForName("pageSize").Value.Value(nil)

		pageSizeValue := pageSizeRawValue.(int64)

		resolver := r.resolver.GetUsers(ctx, startValue, pageSizeValue)

		//if it's array, resolver each element
		gqlResolvers := MkGqlUserResolvers(resolver)
		return GqlResolveValues(ctx, gqlResolvers, field.SelectionSet)

	default:
		panic("Unsupported field")
	}
}

type GqlMutationResolver struct {
	resolver MutationResolver
}

func MkGqlMutationResolver(resolver MutationResolver) GqlMutationResolver {
	return GqlMutationResolver{
		resolver: resolver,
	}
}

func MkGqlMutationResolvers(resolvers []MutationResolver) []GqlResolver {
	gqlResolvers := make([]GqlResolver, len(resolvers))
	for i, resolver := range resolvers {
		gqlResolvers[i] = MkGqlMutationResolver(resolver)
	}
	return gqlResolvers
}

func (r GqlMutationResolver) Resolve(ctx Context, sel ast.SelectionSet) GqlResults {
	return GqlResolveSelections(ctx, sel, r.resolveField)
}

func (r GqlMutationResolver) resolveField(ctx Context, field *ast.Field) GqlResultValue {
	switch field.Name {

	case "updateUserName":

		//for field with parameters
		span, ctx := logging.StartSpanFromContext(ctx, "Mutation -- updateUserName")
		defer span.Finish()

		idRawValue, _ := field.Arguments.ForName("id").Value.Value(nil)

		idValue := idRawValue.(ID)

		nameRawValue, _ := field.Arguments.ForName("name").Value.Value(nil)

		nameValue := nameRawValue.(string)

		resolver := r.resolver.UpdateUserName(ctx, idValue, nameValue)

		//not array, using NamedType of the return type
		gqlResolver := MkGqlUserResolver(resolver)
		return gqlResolver.Resolve(ctx, field.SelectionSet)

	case "updateUser":

		//for field with parameters
		span, ctx := logging.StartSpanFromContext(ctx, "Mutation -- updateUser")
		defer span.Finish()

		idRawValue, _ := field.Arguments.ForName("id").Value.Value(nil)

		idValue := idRawValue.(ID)

		userInputRawValue, _ := field.Arguments.ForName("userInput").Value.Value(nil)

		userInputValue := MakeUserInput(userInputRawValue.(map[string]interface{}))

		resolver := r.resolver.UpdateUser(ctx, idValue, userInputValue)

		//not array, using NamedType of the return type
		gqlResolver := MkGqlUserResolver(resolver)
		return gqlResolver.Resolve(ctx, field.SelectionSet)

	default:
		panic("Unsupported field")
	}
}
