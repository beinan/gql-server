package codegen

import (
	"bytes"
	"html/template"
	"io"
	"strings"

	"github.com/vektah/gqlparser/ast"
)

//GenerateGqlResolver : gen gql resolver's functions
//gql resolvers are the mapper between user's resolver and graphql syntax
func GenerateGqlResolver(cfg GenConfig, w io.Writer) error {
	return generate(
		cfg, w, executeGqlResolverTmpl,
	)
}

const gqlResolverTmpl = `
//Generated by gql-server
//DO NOT EDIT
package gen


import (
	"github.com/beinan/gql-server/logging"
	. "github.com/beinan/gql-server/resolver"
	"github.com/vektah/gqlparser/ast"
)

{{range .Definitions}}
	{{if .IsCompositeType}} {{/* do not generate resolvers for input and leaf types */}}
		{{$typename := .Name}}

		type Gql{{.Name}}Resolver struct {
			resolver {{.Name}}Resolver
		}

		func MkGql{{.Name}}Resolver(resolver {{.Name}}Resolver) Gql{{.Name}}Resolver {
			return Gql{{.Name}}Resolver{
				resolver: resolver,
			}
		}

		func MkGql{{.Name}}Resolvers(resolvers []{{.Name}}Resolver) []GqlResolver {
			gqlResolvers := make([]GqlResolver, len(resolvers))
			for i, resolver := range resolvers {
				gqlResolvers[i] = MkGql{{.Name}}Resolver(resolver)
			}
			return gqlResolvers
		}

		func (r Gql{{.Name}}Resolver) Resolve(ctx Context, sel ast.SelectionSet) GqlResults {
			return GqlResolveSelections(ctx, sel, r.resolveField)
		}

		func (r Gql{{.Name}}Resolver) resolveField(ctx Context, field *ast.Field) GqlResultValue {
			switch field.Name {
				{{range .Fields}}
				case "{{.Name}}":
					{{if .Type | isImmediate}}
						//for immediate value
						return r.resolver.{{.Name | titlePipe}}()
					{{else}}
						//for field with parameters 
						span, ctx := logging.StartSpanFromContext(ctx, "{{$typename}} -- {{.Name}}")
						defer span.Finish()

						{{range .Arguments}}
							{{.Name}}RawValue, _ := field.Arguments.ForName("{{.Name}}").Value.Value(nil)
							{{if .Type | isImmediate}}
								{{.Name}}Value := {{.Name}}RawValue.({{. | argTypePipe}})
							{{else}}
								{{.Name}}Value := Make{{.Type.Name}}({{.Name}}RawValue.(map[string]interface{}))
							{{end}}
						{{end}}
						resolver := r.resolver.{{.Name | titlePipe}}(ctx, {{range .Arguments}}{{.Name}}Value,{{end}})		   
					{{if eq .Type.NamedType ""}}
							//if it's array, resolver each element
							gqlResolvers := MkGql{{.Type.Elem.NamedType}}Resolvers(resolver)
							return GqlResolveValues(ctx, gqlResolvers, field.SelectionSet)
					{{else}}
							//not array, using NamedType of the return type
							gqlResolver := MkGql{{.Type.NamedType}}Resolver(resolver)
							return gqlResolver.Resolve(ctx, field.SelectionSet)
					{{end}}
					{{end}}
				{{end}}
				default:
					panic("Unsupported field")
			}
		}
	{{end}} {{/* end of type checking*/}}
{{end}}


`

func executeGqlResolverTmpl(doc *ast.SchemaDocument) []byte {
	funcMap := template.FuncMap{
		"resolverFieldTypePipe": resolverFieldTypePipe,
		"argTypePipe":           argTypePipe,
		"titlePipe":             strings.Title,
		"isImmediate":           isImmediate,
	}
	tmpl, err := template.New("resolver").Funcs(funcMap).Parse(gqlResolverTmpl)
	if err != nil {
		panic(err)
	}
	var buf bytes.Buffer
	tmpl.Execute(&buf, doc)
	return buf.Bytes()
}
