package codegen

import (
	"bytes"
	"html/template"
	"io"
	"strings"

	"github.com/vektah/gqlparser/ast"
)

//GenerateGqlResolver : gen gql resolver's functions
//gql resolvers are the mapper between user's resolver and graphql syntax
func GenerateGqlResolver(cfg GenConfig, w io.Writer) error {
	return generate(
		cfg, w, executeGqlResolverTmpl,
	)
}

const gqlResolverTmpl = `
//Generated by gql-server
//DO NOT EDIT
package gen


import (
	"github.com/beinan/gql-server/logging"
	. "github.com/beinan/gql-server/resolver"
	"github.com/vektah/gqlparser/ast"
)

{{range .Definitions}}

{{$typename := .Name}}

type Gql{{.Name}}Resolver struct {
	resolver {{.Name}}Resolver
}

func MkGql{{.Name}}Resolver(resolver {{.Name}}Resolver) Gql{{.Name}}Resolver {
	return Gql{{.Name}}Resolver{
		resolver: resolver,
	}
}

func MkGql{{.Name}}Resolvers(resolvers []{{.Name}}Resolver) []GqlResolver {
	gqlResolvers := make([]GqlResolver, len(resolvers))
	for i, resolver := range resolvers {
		gqlResolvers[i] = MkGql{{.Name}}Resolver(resolver)
	}
	return gqlResolvers
}

func (r Gql{{.Name}}Resolver) Resolve(ctx Context, sel ast.SelectionSet) GqlResults {
	return GqlResolveSelections(ctx, sel, r.resolveField)
}

func (r Gql{{.Name}}Resolver) resolveField(ctx Context, field *ast.Field) (GqlResultValue, error) {
	switch field.Name {
		{{range .Fields}}
		case "{{.Name}}":
			{{if .Type | isImmediate}}
				//for immediate value
				return r.resolver.{{.Name | titlePipe}}().Value()
			{{else}}
				//for field with parameters 
       	span, ctx := logging.StartSpanFromContext(ctx, "{{$typename}} -- {{.Name}}")
       	defer span.Finish()

       	{{range .Arguments}}
			   	{{.Name}}Value, _ := field.Arguments.ForName("{{.Name}}").Value.Value(nil)
			 	{{end}}
       	resolver := r.resolver.{{.Name | titlePipe}}(ctx, {{range .Arguments}}{{.Name}}Value.({{. | argTypePipe}}),{{end}})		   
       {{if eq .Type.NamedType ""}}
					//if it's array, resolver each element
					gqlResolvers := MkGql{{.Type.Elem.NamedType}}Resolvers(resolver)
    			return GqlResolveValues(ctx, gqlResolvers, field.SelectionSet), nil
			 {{else}}
					//not array, using NamedType of the return type
					gqlResolver := MkGql{{.Type.NamedType}}Resolver(resolver)
			 		return gqlResolver.Resolve(ctx, field.SelectionSet), nil
       {{end}}
			{{end}}
		{{end}}
		default:
			panic("Unsupported field")
	}
}
{{end}}


`

func executeGqlResolverTmpl(doc *ast.SchemaDocument) []byte {
	funcMap := template.FuncMap{
		"resolverFieldTypePipe": resolverFieldTypePipe,
		"argTypePipe":           argTypePipe,
		"titlePipe":             strings.Title,
		"isImmediate":           isImmediate,
	}
	tmpl, err := template.New("resolver").Funcs(funcMap).Parse(gqlResolverTmpl)
	if err != nil {
		panic(err)
	}
	var buf bytes.Buffer
	tmpl.Execute(&buf, doc)
	return buf.Bytes()
}
