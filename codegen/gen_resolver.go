package codegen

import (
	"bytes"
	"html/template"
	"io"
	"strings"

	"github.com/vektah/gqlparser/ast"
)

//GenerateResolver : gen resolver's functions
func GenerateResolver(cfg GenConfig, w io.Writer) error {
	return generate(
		cfg, w, executeResolverTmpl,
	)
}

const resolverTmpl = `
//Generated by gql-server
//DO NOT EDIT
package gen


import (
	"github.com/beinan/gql-server/concurrent/future"
	. "github.com/beinan/gql-server/resolver"
)

{{range .Definitions}}

{{$typename := .Name}}

type {{.Name}}Resolver interface {
  {{range .Fields}}
      {{.Name | titlePipe}}({{.| argumentPipe}}) {{.| resolverFieldTypePipe}}
  {{end}}
}

type Future{{.Name}}Resolver struct{
	Value future.Future // future of {{.Name}}
}

{{$typename := .Name}}
{{range .Fields}}
func (this Future{{$typename}}Resolver) {{.Name | titlePipe}}({{.| argumentPipe}}) {{.| resolverFieldTypePipe}} {
  {{if .Type | isImmediate}}
    return this.Value.Then(func(value Value) (Value, error) {
		  data := value.({{$typename}})
		  return data.{{.Name | titlePipe}}, nil
	  })
  {{else}}
	panic("{{.Name}} not implemented")
  {{end}}
}
{{end}}
{{end}}
`

func executeResolverTmpl(doc *ast.SchemaDocument) []byte {
	funcMap := template.FuncMap{
		"resolverFieldTypePipe": resolverFieldTypePipe,
		"argTypePipe":           argTypePipe,
		"titlePipe":             strings.Title,
		"argumentPipe":          argumentPipe,
		"isImmediate":           isImmediate,
	}
	tmpl, err := template.New("resolver").Funcs(funcMap).Parse(resolverTmpl)
	if err != nil {
		panic(err)
	}
	var buf bytes.Buffer
	tmpl.Execute(&buf, doc)
	return buf.Bytes()
}
