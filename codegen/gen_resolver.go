package codegen

import (
	"bytes"
	"html/template"
	"io"
	"strings"

	"github.com/vektah/gqlparser/ast"
)

func GenerateResolver(cfg GenConfig, w io.Writer) error {
	return generate(
		cfg, w, executeResolverTmpl,
	)
}

const resolverTmpl = `
//Generated by gql-server
//DO NOT EDIT
package gen

import "github.com/beinan/gql-server/concurrent/future"
import "github.com/beinan/gql-server/graphql"
import "github.com/beinan/gql-server/logging"
import "github.com/beinan/gql-server/middleware"

{{range .Definitions}}
type {{.Name}}Resolver struct {
  Data *{{.Name}}
}

func (r {{.Name}}Resolver) ResolveQueryField(
	ctx Context,
	field *graphql.Field,
) future.Future {
	switch field.Name {
  {{range .Fields}}
    case "{{.Name}}":
    {{if .Type | isImmediate}}
       //for immediate value
       return future.MakeValue(r.Data.{{.Name | titlePipe}}, nil)
    {{else}}
      //for future resolver value
       span, ctx := logging.StartSpanFromContext(ctx, "{{.Name}}")
       defer span.Finish()

       fu := future.MakeFuture(func() (interface{}, error) {
         {{range .Arguments}}
			     {{.Name}}Value, _ := field.Arguments.ForName("{{.Name}}").Value.Value(nil)
			   {{end}}
         return r.Data.{{.Name | titlePipe}}(ctx, {{range .Arguments}}{{.Name}}Value.({{. | argTypePipe}}),{{end}})
		   }) 
       {{if eq .Type.NamedType ""}}
          //if it's array, resolver each element
          return fu.Then(func(data interface{}, err error) (interface{}, error){
            values := data.([]*{{.Type.Elem.NamedType}}) //array of elememnt type
            results := make([]map[string]future.Future, len(values))
            for i, value := range values {
              span, ctx := logging.StartSpanFromContext(ctx, "{{.Type.Elem.NamedType}}")
              valueResolver := {{.Type.Elem.NamedType}}Resolver{value}
              results[i] = middleware.ResolveSelections(ctx, field.SelectionSet, valueResolver)
              span.Finish()
            }
            return future.MakeValue(results, nil), nil
          })
       {{else}}
          //not array
          return fu.Then(func(data interface{}, err error) (interface{}, error){
            value := data.(*{{.Type.NamedType}})
            valueResolver := {{.Type.NamedType}}Resolver{value}
            result := middleware.ResolveSelections(ctx, field.SelectionSet, valueResolver)
            return result, nil
          })
       {{end}}
    {{end}}
  {{end}}
	default:
		panic("unsopported field")
	}
}
{{end}}


`

func executeResolverTmpl(doc *ast.SchemaDocument) []byte {
	funcMap := template.FuncMap{
		"argTypePipe": argTypePipe,
		"titlePipe":   strings.Title,
		"isImmediate": isImmediate,
	}
	tmpl, err := template.New("resolver").Funcs(funcMap).Parse(resolverTmpl)
	if err != nil {
		panic(err)
	}
	var buf bytes.Buffer
	tmpl.Execute(&buf, doc)
	return buf.Bytes()
}

func isImmediate(t *ast.Type) bool {
	n := t.NamedType
	if n == "Int" || n == "Float" || n == "String" || n == "Boolean" || n == "ID" {
		return true
	}
	return false
}

func argTypePipe(arg *ast.ArgumentDefinition) string {
	if arg.DefaultValue != nil {
		arg.Type.NonNull = true
	}
	return typeNamePipe(arg.Type)
}
