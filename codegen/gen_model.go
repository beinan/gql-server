package codegen

import (
	"bytes"
	"html/template"
	"io"
	"strings"

	"github.com/vektah/gqlparser/ast"
)

//GenerateModel generates the go code of model struct
func GenerateModel(cfg GenConfig, w io.Writer) error {
	return generate(
		cfg, w, executeModelTmpl,
	)
}

const modelTmpl = `
//Generated by gql-server
//DO NOT EDIT
package gen

import (
	"github.com/beinan/gql-server/concurrent/future"
	"github.com/beinan/gql-server/graphql"
)

type ID = string
type StringOption = graphql.StringOption

type Future = future.Future

{{range .Definitions}}
type {{.Name}} struct {
  {{range .Fields}}
    {{if .Type | isImmediate}}
      {{.Name | titlePipe}} {{.| modelFieldTypePipe}}
    {{end}}
  {{end}}
}

type {{.Name}}Option struct {
	Value {{.Name}}
	IsSet bool
}

func Make{{.Name}}(data map[string]interface{}) {{.Name}} {
	input := {{.Name}}{}
	{{range .Fields}}
		{{if .Type | isImmediate}}
			{{if .Type.NonNull}}
				input.{{.Name | titlePipe}} = data["{{.Name}}"].({{.| modelFieldTypePipe}})
			{{else}}
				if v, ok := data["{{.Name}}"]; ok {
					input.{{.Name | titlePipe}} = {{.| modelFieldTypePipe}}{
						Value: v.(string),
						IsSet: ok,
					}
				} else {
					input.{{.Name | titlePipe}} = {{.| modelFieldTypePipe}}{
						IsSet: false,
					}
				}
			{{end}}
		{{end}}
	{{end}}
	return input
}

{{end}}
`

func executeModelTmpl(doc *ast.SchemaDocument) []byte {
	funcMap := template.FuncMap{
		"modelFieldTypePipe": modelFieldTypePipe,
		"argumentPipe":       argumentPipe,
		"titlePipe":          strings.Title,
		"isImmediate":        isImmediate,
	}
	tmpl, err := template.New("model").Funcs(funcMap).Parse(modelTmpl)
	if err != nil {
		panic(err)
	}
	var buf bytes.Buffer
	tmpl.Execute(&buf, doc)
	return buf.Bytes()
}
